"use strict";

var Promise = require("lie");

/** @module thaliMobileNativeWrapper */

/*
        METHODS
 */

/**
 * @file
 *
 * This is the primary interface for those wishing to talk directly to the native layer. All the methods defined
 * in this file are asynchronous. However, with the exception of {@link module:thaliMobileNativeWrapper.emitter} and
 * {@link module:thaliMobileNativeWrapper.connect}, any time a method is called the invocation will immediately return
 * but the request will actually be put on a queue and all incoming requests will be run out of that queue. This means
 * that if one calls two start methods then the first start method will execute, call back its promise and only then
 * will the second start method start running. This restriction is in place to simplify the state model and reduce
 * testing.
 *
 * ## Why not just call {@link module:thaliMobileNative} directly?
 * Our contract in {@link module:thaliMobileNative} stipulates some behaviors that have to be enforced
 * at the node.js layer. For example, we can only issue a single outstanding non-connect Mobile().callNative
 * command at a time. We also want to change the callbacks from callbacks to promises as well as change
 * registerToNative calls into Node.js events. All of that is handled here. So as a general rule nobody
 * but this module should ever call {@link module:thaliMobileNative}. Anyone who wants to use the
 * {@link module:thaliMobileNative} functionality should be calling this module.
 */

/**
 * This method instructs the native layer to discover what other devices are within range using the platform's non-TCP
 * P2P capabilities. When a device is discovered its information will be published via
 * {@link event:nonTCPPeerAvailabilityChangedEvent}.
 *
 * This method is idempotent so multiple consecutive calls without an intervening call to stop will not cause a state
 * change.
 *
 * | Error String | Description |
 * |--------------|-------------|
 * | No Native Non-TCP Support | There are no non-TCP radios on this platform. |
 * | Radio Turned Off | The radio(s) needed for this method are not turned on. |
 * | Unspecified Error with Radio infrastructure | Something went wrong with the radios. Check the logs. |
 *
 * @public
 * @returns {Promise<null|Error>}
 * @throws {Error}
 */
module.exports.startListeningForAdvertisements = function() {
  return Promise.resolve();
};

/**
 * This method instructs the native layer to stop listening for discovery advertisements. Note that so long as
 * discovery isn't occurring (because, for example, the radio needed isn't on) this method will return success.
 *
 * This method MUST NOT terminate any existing connections created locally using
 * {@link module:thaliMobileNativeWrapper.connect}.
 *
 * | Error String | Description |
 * |--------------|-------------|
 * | Failed | Somehow the stop method couldn't do its job. Check the logs. |
 *
 * @public
 * @returns {Promise<null|Error>}
 */
module.exports.stopListeningForAdvertisements = function() {
  return Promise.resolve();
};

/**
 * This method has two separate but related functions. It's first function is to begin advertising the Thali peer's
 * presence to other peers. The second purpose is to accept incoming non-TCP/IP connections (that will then be bridged
 * to TCP/IP) from other peers.
 *
 * In Android these functions can be separated but with iOS the multi-peer connectivity framework is designed such
 * that it is only possible for remote peers to connect to the current peer if and only if the current peer is
 * advertising its presence. So we therefore have put the two functions together into a single method.
 *
 * ## Discovery
 * Thali currently handles discovery by announcing over the discovery channel that the Thali peer has had a
 * state change without providing any additional information, such as who the peer is or who the state changes
 * are relevant to. The remote peers, when they get the state change notification, will have to connect to this
 * peer in order to retrieve information about the state change.
 *
 * Therefore the purpose of this method is just to raise the "state changed" flag. Each time it is called a new
 * event will be generated that will tell listeners that the system has changed state since the last call. Therefore
 * this method is not idempotent since each call causes a state change.
 *
 * Once an advertisement is sent out as a result of calling this method typically any new peers who come in range
 * will be able to retrieve the existing advertisement. So this is not a one time event but rather more of a case
 * of publishing an ongoing advertisement regarding the peer's state.
 *
 * ## Incoming Connections
 * By default all incoming TCP connections generated by
 * {@link external:"Mobile('StartUpdateAdvertisingAndListenForIncomingConnections')".callNative} MUST be passed
 * through a multiplex layer. This multiplex layer works by:
 * 1. Creating a new instance of [multiplex](https://www.npmjs.com/package/multiplex) and then pipe it both to and
 * from the thaliMobileNative generated TCP/IP connection.
 * 2. On the multiplex object hook to the new incoming stream callback and for each incoming Node.js stream
 * create a TCP/IP client pointed at the 127.0.0.1 port that we hosted the app at and pipe the content from the Node.js
 * duplex stream pair to/from the newly created TCP/IP client connection.
 *
 * If the thaliMobileNative TCP/IP connection is terminated for any reason then the muxed connection MUST be destroyed
 * as follows:
 * 1. All outgoing TCP/IP connections MUST have `destroy` called on them.
 * 2. The multiplex object itself MUST the have `destroy` called on it.
 *
 * ## Repeated calls
 * By design this method is intended to be called multiple times without calling stop as each call causes the
 * currently notification flag to change. But this method MUST NOT be called with a different router object than
 * previous calls unless there was an intervening call to stop. This restriction is just to reduce our test matrix and
 * because it does not interfere with any of our current supported scenarios. If this method is called consecutively
 * without an intervening stop using different router objects then the callback MUST return a "No Changing router
 * without a stop" error.
 *
 * | Error String | Description |
 * |--------------|-------------|
 * | Bad Router | router is null or otherwise wasn't accepted by Express |
 * | No Changing router without a stop | See previous paragraph. |
 * | No Native Non-TCP Support | There are no non-TCP radios on this platform. |
 * | Radio Turned Off | The radio(s) needed for this method are not turned on. |
 * | Unspecified Error with Radio infrastructure | Something went wrong with the radios. Check the logs. |
 *
 * @public
 * @param {Object} router This is an Express Router object (for example, express-pouchdb is a router object) that the
 * caller wants the non-TCP connections to be terminated with. This code will put that router at '/' so make sure your
 * paths are set up appropriately. The server will be hosted on 127.0.0.1 using whatever port is available and return it
 * in the promise. If stop is called then the system will take down the server so it is no longer available.
 * @returns {Promise<number|Error>} If successful then the promise will return the portNumber where the router object
 * has been attached on 127.0.0.1. If failed then an Error object with one of the above strings will be returned.
 */
module.exports.startUpdateAdvertisingAndListenForIncomingConnections = function(router) {
  return Promise.resolve();
};

/**
 * This method tells the native layer to stop advertising the presence of the peer, stop accepting incoming
 * connections over the non-TCP/IP transport and to disconnect all existing non-TCP/IP transport incoming connections.
 * This also MUST stop the server instance created by the start call.
 *
 * Note that so long as advertising has stopped and there are no incoming connections or the ability to accept them
 * then this method will return success. So, for example, if advertising was never started then this method will
 * return success.
 *
 * | Error String | Description |
 * |--------------|-------------|
 * | Failed | Somehow the stop method couldn't do its job. Check the logs. |
 *
 * @public
 * @returns {Promise<null|Error>}
 */
module.exports.stopAdvertisingAndListeningForIncomingConnections = function() {
  return Promise.resolve();
};

/**
 *  * WARNING: This method is intended for internal Thali testing only. DO NOT USE!
 *
 * This method is only intended for iOS. It's job is to terminate all incoming and outgoing multipeer connectivity
 * framework browser, advertiser, MCSession and stream connections immediately without using the normal stop and
 * start interfaces or TCP/IP level connections. The goal is to simulate what would happen if we switched the
 * phone to something like airplane mode. This simulates what would happen if peers went out of range.
 *
 * This method MUST return "Not Supported" if called on Android.
 *
 * | Error String | Description |
 * |--------------|-------------|
 * | Failed | Somehow the stop method couldn't do its job. Check the logs. |
 * | Not Supported | This method is not support on this platform. |
 *
 * @private
 * @returns {Promise<null|Error>}
 */
module.exports.killConnections = function() {
  return Promise.resolve();
};

/*
        EVENTS
 */

/**
 * When this code receive a peerAvailabilityChanged callback it MUST create a
 * {@link module:NonTCPPeerAvailabilityChangedBridge} object. That call requires passing in a
 * {@link module:NonTCPPeerAvailabilityChangedBridge~GetMultiplexerFunction} function.
 *
 * Before calling start we MUST subscribe for the {@link @NonTCPPeerAvailabilityChangedBridge~closedListener} event.
 *
 * ## GetMultiplexerFunction Implementation
 * This function will submit the multiplexer object that the bridge will use to open connections to the remote peer.
 * When this function is called it MUST call {@link external:"Mobile('Connect')".callNative}. If the callback
 * returns an error then this function MUST return the same error. If it returns a
 * {module:thaliMobileNative~ListenerOrIncomingConnection} object then the following actions MUST be taken.
 *
 * ### listeningPort is not NULL
 * A TCP/IP connection MUST be opened to listeningPort on 127.0.0.1. Then a multiplex object MUST be created and it
 * MUST be piped, in both directions, to the TCP/IP socket. The newly created multiplex object MUST be returned as
 * the function output.
 *
 * ### clientPort and serverPort are not NULL
 * If we have stopped updating advertising and listening for incoming connections then we have some bizarre race
 * condition and we MUST return a "We aren't listening!" error.
 *
 * If we have started updating advertising and listening for incoming connections and the returned serverPort does
 * not match the portNumber we passed to
 * {@link external:"Mobile('StartUpdateAdvertisingAndListenForIncomingConnections')".callNative} then we MUST
 * return a "Old portNumber" error.
 *
 * Otherwise we must have an {@link module:IncomingConnectionsMultiplexer} object. If we haven't received back the
 * response to calling start on that object then something truly bizarre has happened, most likely start and stop
 * on listening were called with the same portNumber and this connect callback is old. But we can't be sure since
 * there are race conditions. So the best we can do is wrap up the following code as a promise and put it on a then
 * after the promise returned by the start call on IncomingConnectionsMultiplexer. Otherwise we MUST call
 * {@link module:IncomingConnectionsMultiplexer.getMultiplex} with the clientPort value.
 *
 * If we get back a null value then we MUST return the error "Race condition, incoming connection died." Otherwise
 * we MUST return the multiplex object we were given.
 *
 * ### If none of the values are null or if they are all null
 * In this case we MUST return the error "Malformed response, bad.".
 *
 * ## Handling the closedListener Event
 *
 *
 *
 * incoming at native layer - create new multiplexer
 * outgoing w/no existing incoming multiplexer - create new multiplexer
 * outgoing w/existing incoming multiplexer - Use existing multiplexer
 * incoming at multiplex layer - There already exists an outgoing multiplex that the other side re-used to send
 * new incoming connections.
 *
 * |                            |incoming at native layer|incoming at multiplex layer|
 * |----------------------------|------------------------|---------------------------|
 * |Outgoing at native layer    | Not Possible           | See below                 |
 * |Outgoing at multiplex layer | See below              | Not Possible              |
 *
 * ### Outgoing at native layer and incoming at multiplex layer
 * In this we have a TCP/IP client socket down to a native TCP/IP server socket and we are pushing data in both
 * directions over it. The main issue is that it's possible for the TCP/IP listener that sits on top of that mess
 * handling incoming connections to timeout and close everything down. The reason is that the timeout is at the
 * higher level TCP/IP listener and so won't see that the multiplexer is still outputting content. So we need to
 * hijack the close on the multiplex object and have it ask "Should we really close?" If content is still flowing
 * in then the answer is no but we can return a yes to the caller. This will cause us to fire a closedListener
 * but we should detect that the multiplexer needs to keep living (for the sake of the incoming connections) and
 * so we should just keep the mux around. But this means that we need to also make sure we unpipe and then when the
 * new nonTCPPeerAvailabityChangeBridge is created it can establish its own pipe to the mux.
 *
 * The same logic does not apply in reverse. The reason is that while the individual TCP/IP client connections we
 * generate from incoming multiplex requests do have timeouts there is no global timeout in Node.js for incoming
 * connections besides the timeout at the native layer for the TCP/IP client. And that timeout should work just fine
 * since it only wants to see content, it really doesn't care where it comes from. So there should never be a global
 * close here except if for some reason the native link is lost but all that will do is make us close all the outgoing
 * TCP/IP connections as part of the closing of the multiplexer. So we are good.
 *
 * [Multiplex] <-> [TCP client socket, node.js]<->[TCP server socket, native]
 * [TCP/IP Listener for Outgoing connections]
 * [Local Server] <-> [TCP/IP client socket to local server]<->[Multiplex incoming stream]
 * [TCP/IP client socket from local app]<->[createStream on Multiplex]
 *
 * We die if:
 * We get a time out on the [TCP client socket, node.js] because this means there is no traffic in either direction.
 *
 * There is no other reason for us to ever die. So in this case we should completely disable any destroy logic
 * associated with the TCP/IP Listener for Outgoing connections. So long as the [TCP client socket, node.js] is
 * seeing traffic then we are good.
 *
 *
 * ### Incoming at native layer and outgoing at multiplex layer
 * [multiplex] <-> [TCP Server Socket, node.js] <-> [TCP client socket, native]
 * [TCP/IP Listener for Outgoing connections]
 * [Local Server] <-> [TCP/IP client socket to local server]<->[Multiplex incoming stream]
 * [TCP/IP client socket from local app]<->[createStream on Multiplex]
 *
 *
 *
 *
 *
 *
 * When the non-TCP layer finds a peer it will issue a nonTCPPeerAvailabilityChanged event. That event will
 * advertise a port that the peer can be connected to at 127.0.0.1.
 *
 * ## The consequences of connecting to the port
 *
 * The first time the returned port is connected to the system MUST take one of the two following actions.
 *
 * When the returned port is connected to for the first time, if there is no existing communication with the remote
 * peer, then the system MUST call the connect API using the peer identifier from the peer associated with the port that
 * was announced. If the connect API call fails then the system
 * MAY choose to retry the connect call. How many times a retry is made is platform dependent. But the `suggestedTCPTimeout`
 * value below is intended to warn callers how long they need to be ready to wait before a connection may succeed. When
 * the system has decided that a connection cannot be made then it MUST close and release the port followed by issuing a
 * nonTCPPeerAvailabilityChanged changed event with portNumber set to null. If the connect succeeds then a mux layer
 * MUST be put into place to allow the caller to open as many simultaneous TCP/IP connections as they want to the remote
 * peer.
 *
 * The mux layer, from the client perspective, works as follows:
 * Each connection to the TCP/IP listener advertised in portNumber will cause a createStream call which will create
 * a full duplex pair of Node.js streams. We then write a buffer copy that copies data from the TCP/IP output
 * stream to the Node.js input stream and vice versa. This means that every incoming TCP/IP connection causes the
 * creation of a matching node.js stream pair. All of these node.js stream pairs will be serialized by multiplex onto
 * a single node.js stream pair. That sole node.js stream pair will then be cross connected to a TCP/IP client
 * connection to the port advertised by PeerAvailabilityChanged. If the PeerAvailabilityChanged connection is lost
 * for any reason then the following MUST occur in the specified order:
 * 1. All the incoming TCP/IP connections to nonTCPPeerAvailabilityChanged port MUST be closed
 * 2. destroy MUST be called on the Multiplex object
 *
 * Some platforms (currently meaning iOS but we suspect Android may join) cannot handle have two native connections
 * between two peers. For example, imagine that peer A wants to initiate a TCP/IP connection with peer B. Historically
 * the way we would try to handle this is by having peer A invite peer B to a MCSession and then establish two
 * output streams (one from each peer) and run the TCP/IP connection over it. If peer B should then decide that it
 * wanted to initiate a TCP connection to peer A then peer B would create a second MCSession and invite peer A to it.
 * The end result is that if both peer A and peer B both simultaneously wanted to establish TCP/IP sessions to each
 * other then they would create two independent MCSession objects between each other. However we have found
 * experimentally that at least as of iOS 8 if two peers establish two simultaneous MCSession objects and start to
 * move a lot of data over them then the output streams will start to randomly fail. To work around this we have to
 * detect when there is an existing non-TCP connection with the desired peer and then re-use it.
 *
 * Specifically, when the first connection is made to the nonTCPPeerAvailabilityChanged portNumber if the platform is
 * iOS then the system MUST determine if it already has an incoming connection from the remote peer associated with
 * the port. If such a connection exists then this means that there must exist a multiplexer connection as defined
 * in {@link module:thaliMobileNativeWrapper.startUpdateAdvertisingAndListenForIncomingConnections}.  In that case
 * this code has to get a hold of the multiplex object being used with the incoming connection and use it as specified
 * above. That is, for each incoming TCP/IP connection to nonTCPPeerAvailabilityChanged portNumber results in a
 * call to createStream and then using pipe to connect the new node.js stream to the TCP/IP connections' streams. This
 * will cause the TCP/IP connections to be sent across the existing link.
 *
 * To make this work anytime (at least on iOS) that we establish a new multiplex object we MUST be ready for that
 * object to start producing new node.js streams using the multiplex constructor's onStream callback notifying of new
 * incoming streams. If listening for incoming streams has not been started then any incoming streams MUST be
 * closed as soon as they are received. If listening for incoming streams has been started then each incoming
 * stream MUST be paired with a TCP/IP client to start method's server instance (e.g. the 127.0.0.1 server started
 * by start) as defined in
 * {@link module:thaliMobileNativeWrapper.startUpdateAdvertisingAndListenForIncomingConnections}. Note that if
 * the incoming connection is torn down for any reason then
 *
 * ## Closing due to inactivity
 * If, after a port has been connected to, there is every a period last longer than 100 ms where there is no open
 * connection to the thaliMobileNativeWrapper port then the system MAY close the thaliMobileNativeWrapper port.
 * If the system closes the thaliMobileNativeWrapper port then it MUST close its connection to the thaliMobileNative
 * port. The system MAY choose to leave the port open and available when when there are no open connections for up to
 * 10 seconds on the off chance that there will be another connection. This is allowed because typically setting up
 * new connections is expensive. However if the system is a max connection situation (e.g. the system has reached
 * the maximum outgoing connections it can support) then it SHOULD close an inactive port immediately.
 *
 * If there are open connections to the thaliMobileNativeWrapper port but in the ast 10 seconds no data has been sent
 * in either direction then the system MUST close the thaliMobileNativeWrapper port and the thaliMobileNative port.
 *
 * After closing the thaliMobileNativeWrapper port the system MUST fire a nonTCPPeerAvailabilityChanged
 * event the same peerIdentifier as the one associated with the closed port and the portNumber in the event MUST be
 * set to null.
 *
 * ## Deciding when to mark peers as not being available
 * Whenever the system believes a peer has disappeared it MUST issue a nonTCPPeerAvailabilityChanged event with the
 * peer's ID and a null portNumber. The actual heuristic used to determine that a peer is gone is platform
 * dependent. For example, on Android it's possible for a device's BLE radio to be on low power while
 * its Bluetooth radio is available on higher power. This would mean that Android would think that a peer was
 * gone (because it no longer sees its BLE announcements) when in fact the peer is still in range. So it's reasonable
 * for Android, if it hasn't receive a peerAvailabilityChanged event for the peer in the last few seconds to start
 * a timer to 30 seconds or even a minute and only then sending a nonTCPPeerAvailabilityChanged event stating that
 * the peer is gone.
 *
 * ## Maximum number of peers to advertise
 * If the system is currently advertising more than 1000 ports then when the next peer is discovered one of the
 * existing ports MUST be closed a nonTCPPeerAvailabilityChanged event with portNumber set to null MUST be fired
 * for the selected peer. And yes, this means that Thali is currently not designed to handle enormous numbers
 * of simultaneous peers.
 *
 * ## Dealing with a maximum number of simultaneous connections
 * Non-TCP transports typically have a fairly low limit on the number of simultaneous connections they will support.
 * Furthermore Thali may restrict this limit even further based on practical experience with a particular transport's
 * ability to handle multiple connections well. If attempts are made to connect to an unconnected TCP/IP port
 * exposed by `portNumber` below when the system has reached its limit of native connections then the connection
 * request MUST be rejected and a maxPeerReached event MUST be fired. The caller MUST NOT attempt to open any
 * subsequent connections until it has closed one.
 *
 * @public
 * @typedef {Object} nonTCPPeerAvailabilityChanged
 * @property {String} peerIdentifier See {@link module:thaliMobileNative~peer.peerIdentifier}.
 * @property {number|null} portNumber If this value is null then the system is advertising that it no longer believes
 * this peer is available. If this value is non-null then it is a port on 127.0.0.1 at which the local peer can
 * connect in order to establish a TCP/IP connection to the remote peer.
 * @property {number} [suggestedTCPTimeout] Based on the characteristics of the underlying non-TCP transport how long
 * the system suggests that the caller be prepared to wait before the TCP/IP connection to the remote peer can be
 * set up.
 */

/**
 * This event is fired whenever the network's state or our use of the network's state has changed.
 *
 * This event MAY start firing as soon as either of the start methods is called. Start listening for advertisements
 * obviously looks for new peers but in some cases so does start advertising. This is because in some cases
 * it's possible for peer A to discover peer B but not vice versa. This can result in peer A connecting to peer B
 * who previously didn't know peer A exists. When that happens we will first a discovery event.
 *
 * This event MUST stop firing when both stop methods have been called.
 *
 * The native layer will make no attempt to filter out peerAvailabilityChanged callbacks. This means it is possible to
 * receive multiple announcements about the same peer in the same state.
 *
 * @public
 * @event nonTCPPeerAvailabilityChangedEvent
 * @type {Object}
 * @property {module:thaliMobileNativeWrapper~nonTCPPeerAvailabilityChanged[]} peers
 */

/**
 * This is used whenever discovery or advertising starts or stops. Since it's possible for these to
 * be stopped (in particular) due to events outside of node.js's control (for example, someone turned off a radio)
 * we provide a callback to track. Note that there is no guarantee that the same callback value couldn't be sent
 * multiple times in a row.
 *
 * @public
 * @event discoveryAdvertisingStateUpdateNonTcpEvent
 * @type {object}
 * @property {module:thaliMobileNative~discoveryAdvertisingStateUpdate} discoveryAdvertisingStateUpdateValue
 */

/**
 * Provides a notification when the network's state changes as well as when our use of the network changes,
 * specifically when discovery or advertising/listening starts and stops. This event can start firing as soon
 * as the system starts.
 *
 * @public
 * @event networkChanged
 * @type {Object}
 * @property {module:thaliMobileNative~NetworkChanged} networkChangedValue
 */

/**
 * This event specifies that a non-TCP communication mechanism was used to successfully connect an incoming connection
 * from a remote peer but the system could not complete a TCP/IP handshake with the `portNumber` on 127.0.0.1 that
 * was passed into the system.
 *
 * @public
 * @event incomingConnectionToPortNumberFailed
 * @property {number} portNumber the 127.0.0.1 port that the TCP/IP bridge tried to connect to.
 */


/**
 * Use this emitter to subscribe to events.
 *
 * @public
 * @fires event:nonTCPPeerAvailabilityChangedEvent
 * @fires event:networkChanged
 * @fires event:incomingConnectionToPortNumberFailed
 * @fires event:discoveryAdvertisingStateUpdateNonTcpEvent
 */
module.exports.emitter = new EventEmitter();

