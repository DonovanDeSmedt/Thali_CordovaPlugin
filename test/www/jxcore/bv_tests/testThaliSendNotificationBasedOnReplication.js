'use strict';

var PouchDB = require('PouchDB');
var tape = require('../lib/thali-tape');
var testUtils = require('../lib/testUtils.js');
var ThaliNotificationServer =
  require('thali/NextGeneration/thaliNotificationServer');
var proxyquire = require('proxyquire');
var sinon = require('sinon');
var express = require('express');
var crypto = require('crypto');
var path = require('path');
var Promise = require('lie');
//var ThaliSendNotificationBasedOnReplication =
//  require('thali/NextGeneration/thaliSEndNotificationBasedOnReplication');
var randomstring = require('randomstring');

var test = tape({
  setup: function (t) {
    t.end();
  },
  teardown: function (t) {
    t.end();
  }
});

function getTestPouchDBInstance(name) {
  // Use a folder specific to this test so that the database content
  // will not interfere with any other databases that might be created
  // during other tests.
  var dbPath = path.join(testUtils.tmpDirectory(),
    'pouch-for-testThaliSendNotificationBasedOnReplication-test');
  var LevelDownPouchDB =
    PouchDB.defaults({db: require('leveldown-mobile'), prefix: dbPath});
  return new LevelDownPouchDB(name);
}

function getRandomlyNamedTestPouchDBInstance() {
  var randomPouchDBName = randomstring.generate({
    length: 40,
    charset: 'alphabetic'
  });
  return getTestPouchDBInstance(randomPouchDBName);
}

/**
 * @public
 * @typedef {?Buffer[]} startArg This is the value to use in the call to start
 * on the thaliSendNotificationBasedOnReplication object.
 */

/**
 * This function will be passed in the PouchDB object being used in the test
 * so that it can set it up.
 *
 * @public
 * @callback pouchDbInitFunction
 * @param {Object} pouchDB
 * @returns {Promise<?Error>}
 */

/**
 * This callback is used to let the test set up the mock, put documents in
 * the DB, check the constructor functions, etc. The values below that start
 * with 'submitted' are the ones that were generated by the test rig and
 * used to create the thaliSendNotificationServer instance. The values that
 * start with used are the values that were passed on by the
 * thaliSendNotificationServer code when calling the ThaliNotificationServer
 * object.
 *
 * @public
 * @callback mockInitFunction
 * @param {Object} mock
 */

/**
 * Lets us do some work after the start and before the stop.
 *
 * @public
 * @callback betweenStartAndStopFunction
 * @param {Object} pouchDB
 * @returns {Promise<?Error>}
 */

// jscs:disable jsDoc
/**
 * Calls start, lets some user code set things up and then calls finish. The
 * ThaliNotificationServer object is fully mocked and so has to be configured
 * using the mockInitFunction.
 *
 * @param {Object} t The tape status reporting object
 * @param {startArg} startArg
 * @param {pouchDbInitFunction} pouchDbInitFunction
 * @param {mockInitFunction} mockInitFunction
 * @param {betweenStartAndStopFunction} [betweenStartAndStopFunction]
 */
// jscs:enable jsDoc
function testStartAndStop(t, startArg, pouchDbInitFunction, mockInitFunction,
                          betweenStartAndStopFunction) {
  var router = express.Router();
  var ecdhForLocalDevice = crypto.createECDH('secp521r1').generateKeys();
  var millisecondsUntilExpiration = 100;
  var pouchDB = getRandomlyNamedTestPouchDBInstance();

  var SpyOnThaliNotificationServerConstructor =
    sinon.spy(ThaliNotificationServer);

  var mockThaliNotificationServer = null;

  pouchDbInitFunction(pouchDB)
    .then(function () {
      var MockThaliNotificationServer =
        function (router, ecdhForLocalDevice, millisecondsUntilExpiration) {
          var spyServer = new SpyOnThaliNotificationServerConstructor(router,
                          ecdhForLocalDevice, millisecondsUntilExpiration);
          mockThaliNotificationServer = sinon.mock(spyServer);
          mockInitFunction(mockThaliNotificationServer);
          return spyServer;
        };

      var ThaliSendNotificationBasedOnReplicationProxyquired =
        proxyquire(
          'thali/NextGeneration/thaliSendNotificationBasedOnReplication',
          { './thaliNotificationServer':
          MockThaliNotificationServer});

      var thaliSendNotificationBasedOnReplication =
        new ThaliSendNotificationBasedOnReplicationProxyquired(router,
          ecdhForLocalDevice, millisecondsUntilExpiration, pouchDB);

      thaliSendNotificationBasedOnReplication.start(startArg)
        .then(function () {
          if (betweenStartAndStopFunction) {
            return betweenStartAndStopFunction(pouchDB);
          }
        }).then(function () {
          return thaliSendNotificationBasedOnReplication.stop();
        }).then(function () {
          return thaliSendNotificationBasedOnReplication._findSequenceNumber()
          .then(function (seq) {
            console.log("My sequence number is " + seq);
          });
        }).then(function () {
          mockThaliNotificationServer.verify();
          t.ok(SpyOnThaliNotificationServerConstructor.calledOnce);
          t.ok(SpyOnThaliNotificationServerConstructor
            .calledWithExactly(router, ecdhForLocalDevice,
                               millisecondsUntilExpiration));
          t.end();
        });
    });
}

function mockStartAndStop(mockThaliNotificationServer, startArg) {
  mockThaliNotificationServer.expects('start')
    .once()
    .withExactArgs(startArg)
    .returns(Promise.resolve());

  mockThaliNotificationServer.expects('stop')
    .once()
    .withExactArgs()
    .returns(Promise.resolve());
}

//test('No peers and empty database', function (t) {
//  var startArg = [];
//  testStartAndStop(t,
//    startArg,
//    function () { return Promise.resolve(); },
//    function (mockThaliNotificationServer) {
//      mockStartAndStop(mockThaliNotificationServer, startArg);
//    });
//});
//
//test('One peer and empty DB', function (t) {
//  var partnerPublicKey = crypto.createECDH('secp521r1').generateKeys();
//  var startArg = [ partnerPublicKey ];
//  testStartAndStop(t,
//    startArg,
//    function () { return Promise.resolve(); },
//    function (mockThaliNotificationServer) {
//      mockStartAndStop(mockThaliNotificationServer, startArg);
//    });
//});
//
//test('One peer with _Local set behind current seq', function (t) {
//  var partnerPublicKey = crypto.createECDH('secp521r1').generateKeys();
//  var startArg = [ partnerPublicKey ];
//  testStartAndStop(t,
//    startArg,
//    function (pouchDB) {
//      return pouchDB.put({ _id: 'id', stuff: 'whatever'})
//        .then(function () {
//          return pouchDB.put(
//            {_id: ThaliSendNotificationBasedOnReplication
//                   .calculateSeqPointKeyId(partnerPublicKey),
//             lastSyncedSequenceNumber: 0});
//        });
//    },
//    function (mockThaliNotificationServer) {
//      mockStartAndStop(mockThaliNotificationServer, startArg);
//    });
//});
//
//test('One peer with _Local set equal to current seq', function (t) {
//  var partnerPublicKey = crypto.createECDH('secp521r1').generateKeys();
//  var startArg = [ partnerPublicKey ];
//  testStartAndStop(t,
//    startArg,
//    function (pouchDB) {
//      return pouchDB.put({ _id: 'id', stuff: 'whatever'})
//        .then(function () {
//          return pouchDB.put(
//            {_id: ThaliSendNotificationBasedOnReplication
//              .calculateSeqPointKeyId(partnerPublicKey),
//              lastSyncedSequenceNumber: 2});
//        });
//    },
//    function (mockThaliNotificationServer) {
//      mockStartAndStop(mockThaliNotificationServer, []);
//    });
//});
//
//test('One peer with _Local set ahead of current seq (and no this should ' +
//     'not happen)', function (t) {
//  var partnerPublicKey = crypto.createECDH('secp521r1').generateKeys();
//  var startArg = [ partnerPublicKey ];
//  testStartAndStop(t,
//    startArg,
//    function (pouchDB) {
//      return pouchDB.put({ _id: 'id', stuff: 'whatever'})
//        .then(function () {
//          return pouchDB.put(
//            {_id: ThaliSendNotificationBasedOnReplication
//              .calculateSeqPointKeyId(partnerPublicKey),
//              lastSyncedSequenceNumber: 50});
//        });
//    },
//    function (mockThaliNotificationServer) {
//      mockStartAndStop(mockThaliNotificationServer, []);
//    });
//});
//
//test('Three peers, one not in DB, one behind and one ahead', function (t) {
//  var partnerNotInDbPublicKey = crypto.createECDH('secp521r1').generateKeys();
//  var partnerBehindInDbPublicKey =
//    crypto.createECDH('secp521r1').generateKeys();
//  var partnerAheadInDbPublicKey = crypto.createECDH('secp521r1').generateKeys();
//  var startArg = [ partnerNotInDbPublicKey, partnerBehindInDbPublicKey,
//                  partnerAheadInDbPublicKey];
//  testStartAndStop(t,
//    startArg,
//    function (pouchDB) {
//      return pouchDB.put({_id: 'id', stuff: 'whatever'})
//        .then(function () {
//          return pouchDB.put(
//            {
//              _id: ThaliSendNotificationBasedOnReplication
//                .calculateSeqPointKeyId(partnerBehindInDbPublicKey),
//              lastSyncedSequenceNumber: 1
//            }
//        );})
//        .then(function () {
//          return pouchDB.put(
//            {_id: ThaliSendNotificationBasedOnReplication
//              .calculateSeqPointKeyId(partnerAheadInDbPublicKey),
//            lastSyncedSequenceNumber: 500}
//          );
//        });
//    },
//    function (mockThaliNotificationServer) {
//      mockStartAndStop(mockThaliNotificationServer,
//                       [ partnerNotInDbPublicKey, partnerBehindInDbPublicKey]);
//    });
//});

//test('two peers with empty DB, update the doc', function (t) {
//  var partnerOnePublicKey = crypto.createECDH('secp521r1').generateKeys();
//  var partnerTwoPublicKey = crypto.createECDH('secp521r1').generateKeys();
//  var startArg = [ partnerOnePublicKey, partnerTwoPublicKey];;
//  testStartAndStop(t,
//    startArg,
//    function () { return Promise.resolve(); },
//    function (mockThaliNotificationServer) {
//      mockThaliNotificationServer.expects('start')
//        .once().withExactArgs([]).returns(Promise.resolve());
//      mockThaliNotificationServer.expects('start')
//        .once().withExactArgs(startArg).returns(Promise.resolve());
//
//      mockThaliNotificationServer.expects('stop')
//        .once().withExactArgs().returns(Promise.resolve());
//    },
//    function (pouchDB) {
//      return new Promise(function (resolve, reject) {
//        pouchDB.put({_id: '33', stuff: 'uhuh'})
//          .then(function () {
//            setTimeout(function () {
//              resolve();
//            }, 10000);
//          }).catch(function (err) {
//            reject(err);
//        });
//      });
//    });
//});

// Make sure we will refresh tokens when they expire

// Test RefreshTimerManager

// Test calculateSeqPointKeyId

// test('Make sure start is idempotent if called with the same arguments',
//  function() {
//
//  });

// Make sure stop is idempotent

// Create three documents
// Set up changes and set up descending
// See what events we get
test('delme', function (t) {
  var pouchDB = getRandomlyNamedTestPouchDBInstance();
  pouchDB.put({_id: '_local/foo', stuff: 'whatever'})
    .then(function () {
      return pouchDB.put({_id: '2', stuff: 'yo'});
    }).then(function () {
      return pouchDB.put({_id: '_local/bar', stuff: 'eek'});
    }).then(function () {
      var changes = pouchDB.changes({descending: true, since: 0, limit: 1})
        .on('change', function (change) {
          console.log('1' + JSON.stringify(change));
        }).on('complete', function (info) {
          console.log('1' + JSON.stringify(info));
        }).on('error', function (err) {
          console.log('1' + JSON.stringify(err));
        });
      var changes2 = pouchDB.changes({since: 'now', live: true})
        .on('change', function (change) {
          console.log('2' + JSON.stringify(change));
          if (change.id === '4') {
            t.end();
          }
        }).on('complete', function (info) {
          console.log('2' + JSON.stringify(info));
        }).on('error', function (err) {
          console.log('2' + JSON.stringify(err));
        });
    }).then(function () {
      return pouchDB.put({_id: '4', stuff: 'ack'});
    });
});

test('sdfsdf', function (t) {
  var pouchDB = getRandomlyNamedTestPouchDBInstance();
  pouchDB.changes({live: true, since: 0, timeout: false})
    .on('change', function (value) {
      console.log(JSON.stringify(value));
      t.end();
    }).on('complete', function (value) {
      console.log(JSON.stringify(value));
    }).on('error', function (err) {
      console.log(JSON.stringify(err));
    });
  pouchDB.put({_id: '33', stuff: 'uhuh'})
    .then(function () {
      console.log('We put');
    });
});

test('dleme', function (t) {
  var foo = { m: function () {}};
  var mock = sinon.mock(foo);
  //mock.expects('m').once().withExactArgs(23).returns(23);
  //mock.expects('m').once().withExactArgs(45).returns(45);
  //mock.expects('m').once().withExactArgs(23).returns(23).once().withExactArgs(45).returns(45);
  mock.expects('m').once().withExactArgs(23);
  mock.expects('m').once().withExactArgs(45);
  console.log(foo.m(45));
  console.log(foo.m(23));
  mock.verify();
  t.end();
});

test('time out', function (t) {
  var cancel = setTimeout(function () {
    console.log(clearTimeout(cancel));
    t.end();
  }, 1);
});

test('buff copare', function (t) {
  var buff1 = new Buffer(10);
  var foo = true;
  console.log(Buffer.isBuffer(buff1));
  console.log(Buffer.isBuffer(foo));
  t.end();
});
